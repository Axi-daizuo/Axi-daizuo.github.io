'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _util = require('util');

var _promisedMongo = require('promised-mongo');

var _promisedMongo2 = _interopRequireDefault(_promisedMongo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, "next"); var callThrow = step.bind(null, "throw"); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function (url) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var connection = (0, _promisedMongo2.default)(url);
  var Promise = opts.promise || require('native-or-bluebird');

  function fixId(obj) {
    if (typeof obj._id === 'string') {
      obj._id = _promisedMongo2.default.ObjectId(obj._id);
    }
    return obj;
  }

  /**
   * Return a model builder for the database connection
   *
   * @param {String} name Collection name
   */
  return function (name) {
    var collection = connection.collection(name);

    var Model = (function () {

      /**
       * Model constructor
       *
       * @param {Object} data Data to construct new model instance with
       */

      function Model(doc) {
        _classCallCheck(this, Model);

        // Expose collection without it appearing in serialized objects
        Object.defineProperty(this, 'collection', {
          value: collection,
          configurable: false,
          enumerable: false,
          writable: false
        });

        // Mix initialization data into instance
        (0, _util._extend)(this, doc);
      }

      /**
       * Validate the model
       *
       * Unlike how validation works in other model systems,
       * this adopts the "generator way" of throwing errors.
       * This means you can use basic language constructs
       * like try/catch blocks to make validation obvious.
       */

      _createClass(Model, [{
        key: 'validate',
        value: (function () {
          var ref = _asyncToGenerator(function* validate() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()

        // Hooks

      }, {
        key: 'beforeValidate',
        value: (function () {
          var ref = _asyncToGenerator(function* beforeValidate() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'beforeCreate',
        value: (function () {
          var ref = _asyncToGenerator(function* beforeCreate() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'beforeUpdate',
        value: (function () {
          var ref = _asyncToGenerator(function* beforeUpdate() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'beforeRemove',
        value: (function () {
          var ref = _asyncToGenerator(function* beforeRemove() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'beforeFetch',
        value: (function () {
          var ref = _asyncToGenerator(function* beforeFetch() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'beforeSave',
        value: (function () {
          var ref = _asyncToGenerator(function* beforeSave() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'afterValidate',
        value: (function () {
          var ref = _asyncToGenerator(function* afterValidate() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'afterCreate',
        value: (function () {
          var ref = _asyncToGenerator(function* afterCreate() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'afterUpdate',
        value: (function () {
          var ref = _asyncToGenerator(function* afterUpdate() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'afterRemove',
        value: (function () {
          var ref = _asyncToGenerator(function* afterRemove() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'afterFetch',
        value: (function () {
          var ref = _asyncToGenerator(function* afterFetch() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()
      }, {
        key: 'afterSave',
        value: (function () {
          var ref = _asyncToGenerator(function* afterSave() {});

          return function value() {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Fetch the data from mongo and mixin any changes
         */

      }, {
        key: 'fetch',
        value: (function () {
          var ref = _asyncToGenerator(function* fetch() {
            // Reject removals of unsaved models
            if (this.isNew()) {
              throw new Error('cannot fetch unsaved model');
            }

            // Run before fetch hook
            yield this.beforeFetch();

            // Get remote state and merge into itself
            var data = yield this.collection.findOne(fixId({ _id: this._id }));
            (0, _util._extend)(this, data);

            // Run after fetch hook
            yield this.afterFetch();
          });

          return function value() {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Save current model state to mongo
         */

      }, {
        key: 'save',
        value: (function () {
          var ref = _asyncToGenerator(function* save() {
            // Use update to sync model state of already persisted records
            if (!this.isNew()) {
              yield this.update();
              return;
            }

            // Run the validator, with before and after hooks
            yield this.beforeValidate();
            yield this.validate();
            yield this.afterValidate();

            // Run before create + save hooks
            yield this.beforeCreate();
            yield this.beforeSave();

            // Insert the document
            var doc = (0, _util._extend)({}, this);
            (0, _util._extend)(this, (yield this.collection.insert(fixId(doc))));

            // Run after create + save hooks
            yield this.afterSave();
            yield this.afterCreate();
          });

          return function value() {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Send updated model state to database
         *
         * @param {Object} data Extra data to add to the model before the send
         */

      }, {
        key: 'update',
        value: (function () {
          var ref = _asyncToGenerator(function* update(data) {
            // Reject updates on unsaved models
            if (this.isNew()) {
              throw new Error('cannot update unsaved model');
            }

            // Merge update data into the model, when supplied
            if (data) {
              (0, _util._extend)(this, data);
            }

            // Run the validator, with before and after hooks
            yield this.beforeValidate();
            yield this.validate();
            yield this.afterValidate();

            // Run before update + save hooks
            yield this.beforeUpdate();
            yield this.beforeSave();

            // Update and re-fetch
            var doc = (0, _util._extend)({}, this);
            yield this.collection.update(fixId({ _id: this._id }), fixId(doc));
            yield this.fetch();

            // Run after update + save hooks
            yield this.afterSave();
            yield this.afterUpdate();
          });

          return function value(_x2) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Remove model state from database
         *
         * NOTE: The model remains usable, and saving will create a new record
         */

      }, {
        key: 'remove',
        value: (function () {
          var ref = _asyncToGenerator(function* remove() {
            // Reject removals of unsaved models
            if (this.isNew()) {
              throw new Error('cannot remove unsaved model');
            }

            // Run before remove hook
            yield this.beforeRemove();

            // Remove the record from mongo
            yield this.collection.remove(fixId({
              _id: this._id
            }));

            // Delete the id, making it a new model
            delete this._id;

            // Run after remove hook
            yield this.afterRemove();
          });

          return function value() {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Check if the model is linked to a mongo record yet
         */

      }, {
        key: 'isNew',
        value: function isNew() {
          return !this._id;
        }

        /**
         * Build a new model
         *
         * @param {Object} data Object of data to build record with
         */

      }], [{
        key: 'build',
        value: function build(data) {
          var _this = this;

          if (Array.isArray(data)) {
            return data.map(function (v) {
              return new _this(v);
            });
          }
          return new this(data);
        }

        /**
         * Find a set of records in mongo and return a collection of models
         *
         * @param {Object} query Object to query the database with
         * @param {Object} options Options to pass to monk
         */

      }, {
        key: 'find',
        value: (function () {
          var ref = _asyncToGenerator(function* find(query, options) {
            var docs = yield this.collection.find(fixId(query), options);
            return this.build(docs);
          });

          return function value(_x3, _x4) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Find one record and return the model
         *
         * @param {Object} query Object to query the database with
         * @param {Object} options Options to pass to monk
         */

      }, {
        key: 'findOne',
        value: (function () {
          var ref = _asyncToGenerator(function* findOne(query, options) {
            var doc = yield this.collection.findOne(fixId(query), options);
            if (!doc) return;
            return this.build(doc);
          });

          return function value(_x5, _x6) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Find one record by id and return the model
         *
         * @param {String} id ID of the record
         * @param {Object} options Options to pass to monk
         */

      }, {
        key: 'findById',
        value: (function () {
          var ref = _asyncToGenerator(function* findById(id, options) {
            var doc = yield this.collection.findOne(fixId({ _id: id }), options);
            if (!doc) return;
            return this.build(doc);
          });

          return function value(_x7, _x8) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Find or create a record and return the model
         *
         * @param {Object} query Object to query the database with
         */

      }, {
        key: 'findOrCreate',
        value: (function () {
          var ref = _asyncToGenerator(function* findOrCreate(query) {
            var doc = yield this.findOne(query);
            if (!doc) {
              doc = yield this.create(query);
            }
            return doc;
          });

          return function value(_x9) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Create or update a record and return the model
         *
         * @param {Object} query Object to query the database with
         * @param {Object} data Data to add to the record
         */

      }, {
        key: 'createOrUpdate',
        value: (function () {
          var ref = _asyncToGenerator(function* createOrUpdate(query, data) {
            data = data || {};

            // First, attempt to find the record
            var doc = yield this.findOne(query);
            if (doc) {
              yield doc.update(data);

              // If that fails, create a new record
            } else {
                (0, _util._extend)(query, data);
                doc = yield this.create(query);
              }

            return doc;
          });

          return function value(_x10, _x11) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Build and save a new model
         *
         * @param {Object} data Object of data to create record with
         */

      }, {
        key: 'create',
        value: (function () {
          var ref = _asyncToGenerator(function* create(data) {
            var doc = this.build(data);
            yield doc.save();
            return doc;
          });

          return function value(_x12) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Update all records matching the given query
         *
         * @param {Object} query Object to query the database with
         * @param {Object} data Object of complete data to overwrite record with
         */

      }, {
        key: 'update',
        value: (function () {
          var ref = _asyncToGenerator(function* update(query, data) {
            var users = yield this.find(query);
            return yield Promise.all(users.map(function (user) {
              return user.update(data);
            }));
          });

          return function value(_x13, _x14) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Update the record matching the given id
         *
         * @param {String} id ID of the record
         * @param {Object} data Object of complete data to overwrite record with
         */

      }, {
        key: 'updateById',
        value: (function () {
          var ref = _asyncToGenerator(function* updateById(id, data) {
            var user = yield this.findOne({ _id: id });
            return yield user.update(data);
          });

          return function value(_x15, _x16) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Remove all records matching the given query
         *
         * @param {Object} query Object to query the database with
         */

      }, {
        key: 'remove',
        value: (function () {
          var ref = _asyncToGenerator(function* remove(query) {
            var users = yield this.find(query);
            return yield Promise.all(users.map(function (user) {
              return user.remove();
            }));
          });

          return function value(_x17) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Remove the record matching the given id
         *
         * @param {String} id ID of the record
         */

      }, {
        key: 'removeById',
        value: (function () {
          var ref = _asyncToGenerator(function* removeById(id) {
            var user = yield this.findOne({ _id: id });
            return yield user.remove();
          });

          return function value(_x18) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Count all records matching the given query
         *
         * @param {Object} query Object to query the database with
         */

      }, {
        key: 'count',
        value: (function () {
          var ref = _asyncToGenerator(function* count(query) {
            return yield this.collection.count(fixId(query || {}));
          });

          return function value(_x19) {
            return ref.apply(this, arguments);
          };
        })()

        /**
         * Define indexes for the model
         */
        // static index() {
        //   return this.collection.index.apply(collection, arguments)
        // }

      }]);

      return Model;
    })();

    // Attach collection at class level

    Object.defineProperty(Model, 'collection', {
      value: collection,
      configurable: false,
      enumerable: false,
      writable: false
    });

    return Model;
  };
};